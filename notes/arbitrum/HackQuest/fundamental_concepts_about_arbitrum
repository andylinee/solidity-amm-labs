# Fundamental Concepts About Arbitrum
## Introduction to Arbitrum

### Core Goal
![image](https://hackmd.io/_uploads/rJRTMZdcel.png)

The core goal of Arbitrum is to ***achieve fast and cost-efficient transactions on the Ethereum network***. By using Optimistic Rollup technology, Arbitrum aims to reduce network congestion and significantly enhance the processing capacity of the Ethereum network.

### Mainnet and Testnet
![image](https://hackmd.io/_uploads/HJV3MZuqlx.png)

The mainnets of Arbitrum used for actual production include ***Arbitrum One and Arbitrum Nova***, which represent the main deployments of the Arbitrum project in real applications. Testnets, such as ***Arbitrum Sepolia, Arbitrum Goerli, and Stylus testnet***, are networks for development and testing purposes and are not included in the mainnet.

---

## Arbitrum Classic
### Overview
Arbitrum One significantly increases transaction throughput and reduces transaction costs by using ***Optimistic Rollups*** technology. Optimistic Rollups are a Layer 2 scaling solution that operates on top of the Ethereum mainnet, providing a more efficient transaction processing method.

### AVM (Arbitrum Virtual Machine)
![image](https://hackmd.io/_uploads/ryMsMbuclx.png)

The AVM (Arbitrum Virtual Machine) is a virtual machine specifically designed for Arbitrum, with the main purpose of ***executing and managing operations and states on the Arbitrum chain***. It efficiently executes programs written or compiled for the EVM (Ethereum Virtual Machine) by reading messages from the inbox, changing the chain's state, and generating outputs.

### ArbOS (the second-layer state machine)
ArbOS is software developed by Offchain Labs that handles all logic and state updates on Arbitrum, operating similarly to a computer or smartphone's ***operating system***. It is responsible for initiating startup and managing other codes on the chain and provides an environment compatible with the Ethereum Virtual Machine (EVM) for executing smart contracts. Therefore, ArbOS plays a role in Arbitrum ecosystem most similar to an operating system.

### Gas and Fees
![image](https://hackmd.io/_uploads/B1XqG-dqle.png)

The two components of fees involved in processing transactions in Arbitrum One are fees for ***L1 (Ethereum mainnet) resources and fees for L2 (Arbitrum) resources***. These fees compensate for the cost of posting transaction data on the Ethereum mainnet and the cost of computation and storage on Arbitrum.

### Problems with Arbitrum Classic
Although Arbitrum One has made progress in improving transaction processing speed and reducing costs, it faces issues such as ***performance and scalability limitations***, ***high transaction fees during network congestion***, and ***complex development and maintenance requirements*** due to the specially designed AVM. Furthermore, despite efforts to achieve EVM compatibility, differences still exist in certain aspects (such as gas cost calculation and block confirmation times).

---

## Arbitrum One
### Arbitrum Nitro
Arbitrum Nitro is a technical stack upgrade of Arbitrum One, bringing users ***reduced fees, increased capacity, and an overall faster experience***. The Nitro upgrade was aimed at improving the performance and efficiency of the Arbitrum One network, rather than creating a separate network.

### Sequencer
![image](https://hackmd.io/_uploads/HJC0oJhqxg.png)

Unlike Ethereum, which primarily relies on transaction fees to determine the order of execution, ***Arbitrum Sequencer operates based on the order of transaction arrival***. This means that Arbitrum adopts a first-come, first-served principle in processing transactions, inserting them into a queue according to the order they are received and then submitting them to L1.

### State Transition Function
![image](https://hackmd.io/_uploads/HJmyQxnclx.png)

The inputs to state transition function include two parts: the ***current state*** (all the information on the blockchain, such as account balances, smart contract code, etc.) and the ***next transaction*** (the transaction that will be processed next, which may change account balances, contract states, etc.). This means that the behavior of state transition function is entirely determined by the current chain state and the next received transaction.

Once a transaction is verified and processed through state transition function, the ***blockchain's state is updated***. Additionally, state transition function sometimes generates a new Layer 2 block, containing a series of transactions and recording their results on the chain, to improve processing speed and efficiency by aggregating multiple transactions on Layer 2, reducing reliance and pressure on Ethereum.

### Two-Phase Transaction Execution in Arbitrum One
![image](https://hackmd.io/_uploads/Hy5GLencel.png)

#### First Phase: Self-Processing on Layer2
A ***"soft confirmation"*** refers to the state of the transaction after ***being processed on Layer2 and updated through state transition function***. At this point, the transaction has not yet been submitted to Ethereum and can still be altered. For users, this step signifies the transaction is complete, but there are actually more steps to ensure security.

#### Second Phase: Acquiring the Transaction Sequence
Nitro ensures the finality of transactions by ***periodically compressing the transaction sequence and posting it on the Ethereum L1 chain***, which becomes the official and final record of the transaction sequence. Once this data is confirmed on Ethereum, the related transactions are considered final, also known as "hard confirmation."

### Geth Sandwich
![image](https://hackmd.io/_uploads/Sy5nYxn9xl.png)

In the "Geth sandwich" structure, ArbOS is located in the middle layer, its primary functions include parsing the data batches issued by the sequencer, calculating the gas cost on Layer 1, and collecting fees to compensate for them. ArbOS acts as a bridge in this structure, connecting the bottom layer's Geth simulating EVM contract execution with the top layer's handling of network requests and other advanced functionalities.

### Fraud Proofs
The primary purpose of the fraud proof mechanism is to ***ensure the correctness of transaction execution***. It does so by allowing any participant to challenge the correctness or authenticity of these transactions within a time window after their submission. If they believe a transaction is incorrect or fraudulent, they can submit a fraud proof to challenge the transaction. The system then verifies the challenge to ensure the correctness and security of all transactions.

#### Workflow of Fraud Proofs
1. **Submit Transactions**: Sequencer submit transactions batch to L1.
2. **Optimistic Execution**: The makenodes validator sends the after state of those transaction to L1 rollups contract. And the rollup contract will assume this state is correct.
3. **Challenge Period**: After submitting state to rollup contract, there is a time window that allows other participants to review these transactions. If they believe a transaction results recorded on L1 is incorrect or fraudulent, they can submit a fraud proof to challenge the transaction.
4. **Verification of Proof**: Once a fraud proof is submitted, the system undertakes a detailed verification process to check if the challenge is valid.
5. **Determination of Outcome**: If the challenge is valid, the incorrect transaction results recorded on L1 is revoked, ensuring correctness. If the challenge is invalid, the original transaction results recorded on L1 is confirmed as accurate.

### Separation of Execution and Verification
![image](https://hackmd.io/_uploads/ryyn2e25lg.png)

The Nitro system achieves both efficient operation execution and reliable verification of execution results by using the same set of source code, but compiling it into two different forms according to the use case. For operation execution, the system uses the Go language compiler to compile the code into native code suitable for the specific computational architecture, ensuring execution efficiency. For verification operations requiring fraud proofs, the code is compiled into binary wasm format, namely WAVM code, which is more suitable for blockchain interaction, allowing for reliable verification of operation results.

### Interactive Fraud Proofs
The main benefit of interactive fraud proofs is resolving disputes off-chain through participant interaction, thus reducing reliance on the blockchain contract. This method narrows down disputes to a specific operation through a series of steps, and the blockchain contract only intervenes at this smallest point to make a final judgment, significantly reducing the blockchain's burden.

### Why Arbitrum One?
#### Arbitrum One's 4 Key Innovations
1. Sequencing + Deterministic Execution
2. Centered Around Geth
3. Separating Execution from Verification
4. Interactive Fraud Proofs in Optimistic Rollup

#### Arbitrum One's Core Advantages
1. **Closer Compatibility with EVM**: Arbitrum One offers a more consistent execution environment with the EVM by directly utilizing Geth.
2. **Simplification**: By leveraging the existing Geth software, Arbitrum One reduces the workload required to create an L2 virtual machine. Now, code can be written in Go instead of a custom language, making it easier to understand and audit.
3. **Lower Costs**: By separating execution from verification, Arbitrum One only compiles to WASM bytecode when a dispute occurs. In normal operations, it directly uses the node's Go code, improving efficiency and performance, thereby reducing costs for users.
4.**Data Compression**: Arbitrum One reduces the cost of posting data on Ethereum by using widely tested compression libraries.

---

## Arbitrum Nova
### Overview
The core of AnyTrust technology is ***the creation of a trusted group, namely Data Availability Committee***, to ensure reliability and availability of data.

### Data Availability Committee
Data Availability Committee, composed of authorized nodes, is responsible for ***storing and managing data on blockchain*** and providing it to other parts of the network when needed.

### Data Availability Certificate (DACert)
![image](https://hackmd.io/_uploads/ByrqLWn5xx.png)

The Data Availability Certificate primarily includes the ***hash value of the data block as its identifier, the expiration time, and evidence signed by the majority of the committee members***.

### Data Availability Servers (DAS)
![image](https://hackmd.io/_uploads/HJ2Uwb2qxg.png)

The ***Sequencer API*** is an interface specifically designed for the Sequencer on the Arbitrum chain for submitting data blocks for storage, while the ***REST API*** is a globally accessible interface that allows data blocks to be retrieved via their hash values.

### Collaboration Mechanism Between Sequencer and Committee
![image](https://hackmd.io/_uploads/ByKgq-ncgg.png)

1. **Data Submission**: When Sequencer has prepared a batch of data and wishes to publish it through the committee, it sends this batch of data along with a set expiration time (e.g., three weeks later) to all committee members. The committee members store this data, using the hash value of the data as an index.
2. **Signing Process**: Subsequently, each committee member signs the hash value of the data and the expiration time, then sends the signature back to Sequencer.
3. **Creating and Publishing DACert**: Once Sequencer has collected enough signatures, it combines these signatures to create a valid Data Availability Certificate (DACert) for this batch of data and then publishes it on the L1. This allows the L2 AnyTrust chain to use these data.
4. **Fallback Plan**: If Sequencer cannot collect enough signatures within a few minutes, it stops attempting to publish the data through the committee and instead directly publishes the complete data on the L1 chain, similar to the practice on non-AnyTrust chains. L2 understands both methods of data publication and will process them correctly.

### The Core Difference Between One and Nova
The ***data availability*** for One/Nitro is on-chain (Ethereum mainnet), whereas for Nova, it is off-chain (Data Availability Committee, DAC).

### Why Nova?
Since Arbitrum Nova can reduce reliance on Ethereum mainnet resources, thereby lowering transaction costs and increasing processing speed, it is particularly suited for applications sensitive to transaction speed and cost, such as gaming and social media applications.

---

## Arbitrum Orbit
### Overview
![image](https://hackmd.io/_uploads/r136Ff29gl.png)

Arbitrum Orbit allows users to build their own ***Layer 3***, a layer established on top of the Ethereum mainnet (Layer 1) and Layer 2, to meet their specific use scenarios and business requirements.

### Why Orbit?
The main advantage of the Orbit chain in offering custom gas tokens is that it ***allows any ERC-20 token to be used as the native gas token for paying gas fees on the network***. This enables projects to seamlessly integrate with their application ecosystems, offering users more flexible payment options. By supporting alternative ERC-20 tokens as a method of gas payment, the Orbit chain not only enhances its adaptability and user experience but also provides projects with more customization and optimization opportunities.

The main benefit of EVM+ compatibility on the Orbit chain is that it ***provides developers with the ability to use multiple programming languages to develop EVM-compatible smart contracts***. This not only increases development flexibility, allowing developers to choose the language that best fits their expertise and project needs, but it also expands the developer community that can participate in development. By supporting languages like Solidity, C, C++, and Rust, the Orbit chain ensures a broader capability for smart contract development and deployment, thereby fostering the construction of a richer and more efficient dApp ecosystem.

---

## Arbitrum Stylus
### Overview
The introduction of Arbitrum Stylus technology marks a significant upgrade to the Arbitrum Nitro technology stack, with one of its most notable changes being the addition of a second virtual machine—WebAssembly (WASM) virtual machine—to the EVM. This change brings several advantages, the most important of which is significantly ***expanding the range of programming languages available for blockchain contract development***.

### How does Stylus Work?
![image](https://hackmd.io/_uploads/BJM-mmn5xl.png)

1. **Coding**: Developers can choose any language that can be compiled into WASM (WebAssembly) to write smart contracts. Initially, Stylus will support languages such as Rust, C, and C++, with Rust offering a rich development toolkit.
2. **Compiling**: Smart contract code is first compiled from a high-level language (such as Rust, C, or C++) into WASM format. It is then compiled into native code suitable for specific hardware platforms using a tool called ArbWasm.
3. **Executing**: The compiled program executes within the Wasmer runtime, a high-performance runtime specifically designed for WASM, intended to run WASM files in non-browser environments.
4. **Verifying**: In most cases, the execution of smart contracts will compile directly into native code and run smoothly. In the event of a dispute among verifiers, Stylus uses the Nitro technology explained earlier, converting the execution history back into WASM format for verification and dispute resolution on Ethereum.

### Why Stylus?
1. **Native Ethereum Development with Popular Programming Languages**:Build applications on Arbitrum's vast ecosystem using popular WASM-compatible languages like Rust, C, and C++, combining popular internet programming languages with native blockchain smart contract languages.
2. **Full Composability**:Solidity contracts and Stylus contracts are fully interoperable. If working in Solidity, developers can call Rust programs. If working in Rust, all Solidity features are directly usable.
3. **Faster Computation, Lower Costs**:Due to the efficiency of WASM programs, Stylus contracts are over ten times faster and incur significantly lower gas fees. When using Stylus, the cost of memory is reduced by 100-500 times.
4. **Enabling New Use Cases**:Access to the mature WASM ecosystem through Stylus opens up new EVM use cases that were previously unattainable. For example, bringing existing games written in C++ onto the blockchain and accessing computation-intensive AI models becomes much easier.

## Conclusion
![image](https://hackmd.io/_uploads/HJxAEQ25gl.png)

There are two Arbitrum chains: Arbitrum One and Arbitrum Nova, both of which utilize Arbitrum's Nitro technology stack at their core. However, Arbitrum One implements Rollup protocol, while Nova implements AnyTrust protocol. Users and developers can choose based on their security/transaction cost needs. Developers can also opt to create their own Arbitrum chains, which, running on Arbitrum's second layer, are referred to as Orbit chains.Arbitrum One is designed for general use, providing a solution with much more trustless and decentralization for running Ethereum-compatible smart contracts. On the other hand, Arbitrum Nova is designed for applications that require higher transaction throughput and do not necessitate full decentralization, such as gaming and social media.

---


# Arbitrum's Modular Tech Stack
- Video: The L2 Modular Stack - Arbitrum Workshop by Swagtimus, Developer Evangelist at the Arbitrum Foundation (https://www.youtube.com/watch?v=QfP08S8pSsc
## Modular Stack & Multi-VM Support)
Arbitrum supports ***multiple languages and execution environments***, giving developers real flexibility on-chain:
- In addition to ***EVM***, Arbitrum supports ***WebAssembly (WASM)*** natively, meaning you can write contracts in ***Rust, C, or C++***
- The ***Stylus upgrade allows EVM and WASM VMs to run side-by-side***, with cross-calling support 🤯
## Multiple Node Implementations & Decentralized Resilience
Arbitrum has three node clients, each with different performance focuses:
- ***Nitro*** (standard)
- ***Nevermind*** (ultra-performant)
- ***Aragon*** (storage-optimized)

More node types = greater decentralization and network resilience.
## Time Boost: Fair MEV Governance Mechanism
No more sandwich attacks!
- A new ***Express Lane auction*** mechanism allows only ***backrunning***, not frontrunning
- MEV profits are redistributed to the ***DAO***, improving fairness and sustainability
## Orbit: Launch Your Own Arbitrum Chain
Want to build your own L2 or L3? ***Orbit SDK*** makes it easy:
- ***Customize gas tokens, add precompiles, and define permission systems***
- Modular by design, adaptable for all kinds of use cases
## Cross-Chain Interoperability & Universal Intent Engine
Worried about multi-chain fragmentation? Arbitrum is building a ***unified cross-chain architecture***:
- Enables ***interoperability of assets and contract calls across Arbitrum chains***
- Designed to support ***low-trust, permissionless*** cross-chain messaging infrastructure


---


# Open House: Unlocking High-Performance Rust Smart Contracts on Arbitrum Stylus with OpenZeppelin
- Lecturers: 
    - Arbitrum Developer Evangelist Swagtimus (@swagtimus)
    - OpenZeppelin Engineer Daniel Bigos (@bidzyyys)
- Video link: https://www.youtube.com/watch?v=yFrc3dwx9vg 

## Guidelines
### What Is Stylus—and Why Does It Matter?
- Stylus is Arbitrum’s WASM smart contract runtime that supports ***Rust / C / C++***
- It runs ***in parallel with the EVM*** and enables ***cross-VM interoperability***
- Offers much ***higher performance and lower gas fees***
### Why Write Smart Contracts in Rust?
- Strong static typing and compile-time safety
- Rich ecosystem and dev tools (like `cargo`, `crates.io`)
- Compared to Solidity, Rust offers ***better performance, testability, and safety***
### Introducing the OpenZeppelin Stylus Library
- OpenZeppelin is ***porting its battle-tested security libraries*** to the Stylus Rust environment
- Rust developers can now leverage tools like `AccessControl`, `ERC20`, and `Ownable`—just like in the EVM world
### End-to-End Dev Experience Walkthrough
- Install Stylus CLI → Scaffold a Rust contract project
- Import OpenZeppelin libraries → Write, compile, and deploy contracts
- Showcase of ***Rust-Solidity contract interoperability***


---
1. What is the core goal of Arbitrum? 
> The core goal of Arbitrum is to achieve fast and cost-efficient transactions on the Ethereum network. By using Optimistic Rollup technology, Arbitrum aims to reduce network congestion and significantly enhance the processing capacity of the Ethereum network.

2. Which networks are included in Arbitrum's mainnet?
> The mainnets of Arbitrum used for actual production include Arbitrum One and Arbitrum Nova, which represent the main deployments of the Arbitrum project in real applications. Testnets, such as Arbitrum Sepolia, Arbitrum Goerli, and Stylus testnet, are networks for development and testing purposes and are not included in the mainnet.

3. The main advantage of Orbit chain in providing custom gas tokens is
> The main advantage of the Orbit chain in offering custom gas tokens is that it allows any ERC-20 token to be used as the native gas token for paying gas fees on the network. This enables projects to seamlessly integrate with their application ecosystems, offering users more flexible payment options. By supporting alternative ERC-20 tokens as a method of gas payment, the Orbit chain not only enhances its adaptability and user experience but also provides projects with more customization and optimization opportunities.